export const tutorialPosts = [
  {
    slug: "train-model-ubuntu",
    title: "Train Model di Ubuntu",
    date: "2025-04-19",
    description: "Panduan praktis untuk melatih model machine learning di Ubuntu mulai dari instalasi environment hingga eksekusi training dengan lancar.",
    paragraphs: [
      "Ubuntu adalah salah satu sistem operasi berbasis Linux yang banyak digunakan untuk pengembangan perangkat lunak, termasuk machine learning. Dalam tutorial ini, kita akan membahas langkah langkah untuk melatih model YOLOv8 di Ubuntu. YOLOv8 adalah salah satu algoritma deteksi objek yang paling gacor dan efisien saat ini.",
      "Langkah pertama adalah memastikan bahwa sistem Ubuntu Anda memiliki Python dan pip terinstal. Python adalah bahasa pemrograman yang akan kita gunakan untuk melatih model, sedangkan pip adalah alat untuk mengelola library Python. Jika belum terinstal, Anda dapat menginstalnya dengan mudah menggunakan perintah di bawah ini.",
      "Setelah Python dan pip terinstal, kita perlu membuat virtual environment. Virtual environment membantu kita mengisolasi dependency proyek agar tidak bercampur dengan sistem utama. Setelah membuat virtual environment, aktifkan dan instal library yang diperlukan seperti PyTorch dan ultralytics (library untuk YOLOv8).",
      "Langkah berikutnya adalah menyiapkan dataset. Dataset ini harus memiliki struktur yang sesuai dengan format YOLO, yaitu folder dengan file gambar dan file label dalam format TXT. Anda dapat menggunakan dataset publik atau membuat dataset sendiri dengan alat seperti LabelImg ataupun roboflow.",
      "Setelah dataset siap, kita dapat mulai melatih model YOLOv8. Proses ini melibatkan pemanggilan perintah sederhana menggunakan library ultralytics. Anda juga dapat menyesuaikan parameter seperti jumlah epoch, ukuran batch, optimizer dan lainnya untuk mendapatkan hasil yang optimal.",
    ],
    codes: [
      "#disclaimer tutorial ini merupakan lanjutan dari tutorial cara menginstal venv. \n #apabila belum dibaca sokin aja ke agungg.com/ilmu-mahal/Venv",
      "# Langkah 1: Instal Python dan pip\nsudo apt update\nsudo apt install python3 python3-pip -y\n\n# Verifikasi instalasi\npython3 --version\npip3 --version",
      "# Langkah 2: Buat dan aktifkan virtual environment\npython3 -m venv yolov8-env\nsource yolov8-env/bin/activate\n\n# Instal dependency\npip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cpu\npip install ultralytics",
      "# Langkah 3: Struktur dataset YOLO\n# Pastikan dataset Anda memiliki struktur seperti ini:\n# dataset/\n# ├── images/\n# │   ├── train/\n# │   ├── val/\n# ├── labels/\n# │   ├── train/\n# │   ├── val/\n\n# Contoh penggunaan LabelImg untuk anotasi:\npip install labelImg\nlabelImg",
      "# Langkah 4: Latih model YOLOv8\nfrom ultralytics import YOLO\n\n# Load model YOLOv8, kalau pc anda kentang gunakan yang v8n kalau lebih gacor bisa yang s,x,dll\nmodel = YOLO('yolov8n.pt')\n\n# Latih model pastikan sudah mengisi path pada dataset.yaml\nmodel.train(data='path/to/dataset.yaml', epochs=50, imgsz=640, batch=16)\n\n# Evaluasi model\nmetrics = model.val()\nprint(metrics)",
    ],
    languages: [
      "bash",
      "bash",
      "bash",
      "bash",
      "python",
    ],
    images: [
      "/assets/ubuntu.webp",
      "",
      "",
      "",
    ],
    formulas: [
      "",
      "",
      "",
    ],
  },
  {
    slug: "estimasi-jarak",
    title: "Estimasi Jarak Menggunakan YOLO dan Mediapipe Pose",
    date: "2025-03-01",
    description: "Panduan menghitung jarak menggunakan bounding box YOLO dan pose Mediapipe dengan kalibrasi dan implementasi kode.",
    paragraphs: [
      "Sebelum adanya visi komputer, estimasi jarak objek dari kamera dilakukan dengan menggunakan pengukuran fisik. Namun, dengan kemajuan teknologi, kita dapat menggunakan algoritma deteksi objek dan analisis pose untuk memperkirakan jarak objek secara otomatis. Dalam tutorial ini, kita akan membahas dua metode untuk memperkirakan jarak objek dari kamera menggunakan bounding box dari model YOLO dan menggunakan koordinat dari Mediapipe Pose.",
      "Tutorial ini hanya membutuhkan satu buah kamera dan satu objek yang ukurannya diketahui. Kita akan menggunakan YOLO untuk mendeteksi objek dan mendapatkan ukuran bounding box, serta Mediapipe Pose untuk mendapatkan koordinat dari titik-titik tubuh manusia. Terakhir kita juga membutuhkan niat dan usaha untuk belajar, tanpa banyak yapping lagi ayo kita mulai.",
      "Contoh pertama akan kita mulai dari estimasi jarak menggunakan output bounding box, yang didapatkan dari model yolo. Kita akan menggunakan konsep focal length pixel untuk pendekatan ini. Focal length pixel adalah jarak antara lensa kamera dan sensor gambar dalam satuan piksel. Kita dapat menghitung focal length pixel dengan rumus sebagai berikut :",
      "Dimana :\n- fp = focal length pixel\n- D = jarak objek nyata (ex : 100cm). \n- Hb = tinggi bounding box dalam satuan pixel\n- Ho = tinggi objek nyata (ex : 180cm).",
      "Pasti kalian bingung bagaimana caranya mendapatkan tinggi bounding box? Agar tidak bingung kita akan lihat implementasinya dalam kode berikut ini. Dimana kita akan mencoba mencari tinggi bounding box dengan kode berikut. Pastikan sudah setup venv dll. ",
      "Setelah running kita cukup melihat ke pojok atas maka dapat dilihat nilai tinggi bounding box (px) dalam bentuk pixel yang siap diinputkan kedalam rumus pada paragraf sebelumnya. Kode yang gacor kan? itu merupakan tes1.py pada proyek kursi roda otonom yang saya kembangkan saat berkuliah. Print nilai tinggi tersebut menggunakan library OpenCv (cv2.) yang merupakan library untuk memproses citra dan video. Selain untuk print nilai Bounding box juga digambar dengan menggunakan fungsi cv2.rectangle. Fungsi cv2.rectangle digunakan untuk menggambar kotak persegi panjang pada citra. Intinya mantap.",
      "Selanjutnya setelah kita mendapatkan Fp, kita dapat menghitung jarak objek dari kamera dengan menggunakan rumus berikut :",
      "Dimana :\n- D = jarak objek dari kamera dalam satuan cm\n- fp = focal length pixel\n- Ho = tinggi objek nyata (ex : 180cm)\n- hb = tinggi bounding box dalam satuan pixel.",
      "Rumus sangat gacor dan mudah dipahami. Tidak perlu kita beli lidar mahal untuk mendapatkan jarak dari kamera. Cukup lakukan implementasi seperti pada kode berikut, pastikan sudah melakukan instalasi library ultralytics dll.",
      "Namun perlu diingat cara ini memiliki beberapa kelemahan, yang pertama jarak yang dihasilkan dipengaruhi oleh performa model YOLO yang digunakan. Jika model tidak dapat mendeteksi objek dengan baik, maka estimasi jarak juga akan terpengaruh. Selain itu, cara ini juga tidak dapat digunakan untuk objek yang terlalu dekat dengan kamera, Ketika objek terlalu dekat dengan kamera, bounding box yang dihasilkan oleh YOLO dapat melampaui batas frame gambar, hal ini menyebabkan ukuran bounding box tidak akurat karena sebagian objek berada di luar area yang terdeteksi. Pada pengujian kursi roda otonom saya, jarak terdekat yang dapat terdeteksi adalah 1.3 meter. Hal ini disebabkan oleh ukuran objek yang terlalu kecil dalam frame gambar, sehingga bounding box yang dihasilkan tidak dapat memberikan estimasi jarak yang akurat. Untuk mengatasi masalah ini, kita perlu menggunakan metode lain untuk memperkirakan jarak objek dari kamera.",
      "Solusinya ialah menggunakan Mediapipe Pose untuk mendapatkan koordinat dari titik-titik tubuh manusia. Mediapipe Pose adalah library yang digunakan untuk mendeteksi pose tubuh manusia dalam gambar atau video. Dengan menggunakan Mediapipe Pose, kita dapat mendapatkan koordinat dari titik-titik tubuh manusia, seperti bahu, pinggul, lutut, dan lainnya. Dengan mengetahui posisi titik-titik tubuh manusia, kita dapat menghitung jarak antara objek dan kamera dengan lebih akurat. Agar makin gacor kita bisa menyatukan keduanya, walaupun berat namun akurat presisi dan mantap.",
      "Dalam menentukan jarak dengan menggunakan pose terdapat sebuah metode yaitu Euclidean. Euclidean dalam piksel adalah metode untuk mengukur jarak lurus antara dua titik dalam ruang gambar, yang biasanya diukur dalam piksel. Tanpa banyak basa basi berikut merupakan rumusanya :",
      "Dimana :\n- dp = jarak Euclidean dalam piksel\n- x1, y1 = koordinat titik pertama (x1, y1)\n- x2, y2 = koordinat titik kedua (x2, y2)\n- sf = skala faktor yang digunakan untuk mengonversi jarak Euclidean dalam piksel menjadi jarak nyata.",
      "Setelah mendapatkan jarak dalam bentuk piksel kita bisa lanjut untuk mengkonversi jarak tersebut ke dalam satuan nyata. Kita bisa menggunakan rumus berikut :",
      "Dimana :\n- Dm = jarak nyata dalam satuan cm\n- K = konstanta kalibrasi yang ditentukan berdasarkan pengukuran objek nyata dan jarak Euclidean dalam piksel.\n- dp = jarak Euclidean dalam piksel.",
      "Untuk mendapatkan nilai K kita bisa menggunakan rumus berikut :",
      "Dimana :\n- Jo = ukuran objek nyata dalam satuan cm\n- Up = jarak Euclidean dalam piksel.",
      "Dengan menggunakan rumus-rumus di atas, kita dapat menghitung jarak objek dari kamera dengan lebih akurat. Berikut adalah contoh implementasi kode untuk menghitung jarak objek menggunakan Mediapipe Pose dan Euclidean.",
      "Fungsi ini menghitung jarak dalam piksel antara dua titik pose dari MediaPipe lalu mengalikan dengan lebar gambar untuk mendapatkan jarak dalam piksel. Setelah itu kita bisa mengkonversi jarak dalam piksel menjadi jarak nyata dengan menggunakan rumus yang telah kita bahas sebelumnya. Adapun penerapannya dalam kode adalah sebagai berikut :",
      "Setelah jarak Euclidean didapat, dikalikan dengan faktor konversi untuk memperkirakan lebar atau jarak dalam meter. Mantap kita sudah mendapatkan jarak objek dari kamera dengan menggunakan pose. Tinggal kita pilih saja landmark mana yang akan digunakan, misalnya bahu, pinggul, lutut, atau titik lainnya. Dengan menggunakan metode ini, kita dapat memperkirakan jarak objek dari kamera dengan lebih akurat dan dapat digunakan untuk berbagai aplikasi seperti pengenalan wajah, pelacakan objek, dan banyak lagi. Berikut contohnya menggunakan lengan kanan:",
      "Kita sudah berhasil mendapatkan jarak dengan dua metode yang berbeda. Cukup dengan satu kamera kita sudah bisa mendapatkan estimasi jarak objek dari kamera dengan akurasi yang cukup baik. Namun, perlu diingat bahwa hasil estimasi jarak ini dapat bervariasi tergantung pada kondisi pencahayaan, sudut pandang kamera, dan faktor lainnya. Oleh karena itu, penting untuk melakukan pengujian dan kalibrasi lebih lanjut untuk mendapatkan hasil yang lebih akurat. Intinya Mantap.",
    ],
    codes: [
      "",
      "",
      "",
      "",
      "import cv2\nimport time\nimport math\nfrom ultralytics import YOLO\n\n# Inisialisasi model YOLOv8\nmodel = YOLO('best100epoch.pt')\n\n# Inisialisasi video capture\ncap = cv2.VideoCapture(0)\ncap.set(3, 1366)\ncap.set(4, 768)\n\ndef hitung_tinggi_bounding_box(y1, y2):\n    return y2 - y1\n\nwhile True:\n    # Capture frame dari video\n    ret, frame = cap.read()\n    if not ret:\n        break\n\n    # Convert frame ke RGB\n    img_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n\n    # Deteksi objek menggunakan YOLO\n    results = model.predict(img_rgb, stream=True)\n    \n    # Proses hasil deteksi\n    for r in results:\n        boxes = r.boxes\n        for box in boxes:\n            confidence = math.ceil((box.conf[0] * 100)) / 100\n            if confidence > 0.7: #Set nilai confidence minimal 0.7 biar biar benda benda goib ga ikutan wkwkwk\n                cls = int(box.cls[0])\n                if cls == 0:  #Disini kita pakai manusia sebagai objek\n                    x1, y1, x2, y2 = map(int, [box.xyxy[0][0], box.xyxy[0][1], box.xyxy[0][2], box.xyxy[0][3]])\n                    tinggi_bounding_box = hitung_tinggi_bounding_box(y1, y2) #Jarak dari koordinat y1 y2 dihitung untuk dapat tingginya\n\n                    # Gambar bounding box dan tinggi di frame\n                    cv2.rectangle(frame, (x1, y1), (x2, y2), (255, 0, 0), 2)\n                    cv2.putText(frame, f'Tinggi: {tinggi_bounding_box}px', (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)\n\n    # Tampilkan frame\n    cv2.imshow('Webcam', frame)\n    \n    # Tekan 'q' untuk keluar\n    if cv2.waitKey(1) & 0xFF == ord('q'):\n        break\n\n# Release video capture\ncap.release()\ncv2.destroyAllWindows()",
      "",
      "",
      "",
      "#Contoh penggunaannya (nilai dibawah ini hasil pengujian terdahulu)\nfocal_length_pixel = 481\ntinggi_objek_nyata = 181\n\ndef hitung_jarak(tinggi_bounding_box, focal_length_pixel, tinggi_objek_nyata):\n   if tinggi_bounding_box == 0:\n      return float('inf')  #Handling error mantap\n   jarak = (tinggi_objek_nyata * focal_length_pixel) / tinggi_bounding_box\n   return jarak / 100\n\ntinggi_bounding_box = y2 - y1 #pastikan sudah konversi integer ex : x1, y1, x2, y2 = map(int, [x1, y1, x2, y2]) \n\n#Masukan nilai-nilainya\njarak_meter = hitung_jarak(tinggi_bounding_box, focal_length_pixel, tinggi_objek_nyata)\n\n#Tampilkan nilainya dengan OpenCV\ncv2.putText(img, f'Distance Yolo: {jarak_meter:.2f}', (10, 150), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 0), 2)",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "def hitung_jarak_euclidean(landmark1, landmark2, lebar_img):\n    jarak_pix = math.sqrt((landmark1.x - landmark2.x) ** 2 + (landmark1.y - landmark2.y) ** 2) * lebar_img\n    return jarak_pix",
      "k = 10.622",
      "siku_kanan = pose_results.pose_landmarks.landmark[mp_pose.PoseLandmark.RIGHT_ELBOW]\npergelangan_kanan = pose_results.pose_landmarks.landmark[mp_pose.PoseLandmark.RIGHT_WRIST\njarak_pix = hitung_jarak_euclidean(siku_kanan, pergelangan_kanan, lebar_img)\n\n\njarak_lengan = (k / jarak_pix) * 10\n#cv2.putText jangan lupa\ncv2.putText(img, f'MediaPipe Shoulder Distance: {jarak_mediapipebahu:.2f'}, (10 , 210), cv2.FONT_HERSHEY_SIMPLEX,0.6, (0,0,0),2)",
    ],
    languages: [
      "",
      "",
      "",
      "",
      "python",
      "",
      "",
      "",
      "python",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "python",
      "python",
      "python",
    ],
    images: [
      "/assets/cameraman.webp",
      "",
    ],
    formulas: [
      "",
      "",
      "f_p=\\frac{D\\times h_b}{H_o}",
      "",
      "",
      "",
      "D = \\frac{f_p \\times H_o}{h_b}",
      "",
      "",
      "",
      "",
      "d_p = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} \\times s_f",
      "",
      "D_m = \\left(\\frac{K}{{d_p}}\\right)",
      "",
      "K = J_o \\times U_p",

    ],
  },
  {
    slug: "Venv",
    title: "Panduan Lengkap Setup venv",
    date: "2025-04-19",
    description: "Cara mudah membuat dan mengelola virtual environment (venv) di Python untuk memisahkan dependensi proyek secara rapi dan efisien.",
    paragraphs: [
      "Virtual Environment (venv) adalah salah satu fitur penting dalam pengembangan Python modern. Dengan venv, Anda dapat membuat lingkungan terisolasi untuk setiap proyek Python Anda. Hal ini sangat berguna untuk menghindari konflik antara dependensi proyek yang berbeda, terutama jika bekerja pada beberapa proyek dengan versi pustaka yang tidak kompatibel.",
      "Membuat virtual environment sangatlah mudah dan hanya membutuhkan beberapa langkah sederhana. Pertama tama pastikan vscode sudah terinstall di device anda. Kedua pastikan juga bahwa python sudah terinstall di device anda. Jika belum silahkan install terlebih dahulu. Anda bisa menginstall python melalui website resmi python atau menggunakan package manager seperti apt, brew, atau choco tergantung pada sistem operasi yang Anda gunakan. Berikut cara menginstallnya menggunakan Choco pada Windows.",
      "Setelah python terinstall, kita bisa langsung buka vscode dan membuat folder baru untuk proyek kita. Setelah itu buka terminal di vscode dan navigasikan ke folder proyek yang telah kita buat. Setelah berada di dalam folder proyek, kita bisa membuat virtual environment dengan menggunakan ctrl + shift + p lalu ketikkan python: create environment. Setelah itu pilih venv dan tunggu hingga proses selesai. Setelah selesai kita bisa melihat folder baru bernama venv di dalam folder proyek kita. Folder ini berisi semua dependensi yang diperlukan untuk proyek kita.",
      "Setelah virtual environment berhasil dibuat, kita perlu mengaktifkannya agar dapat menggunakan dependensi yang telah diinstal. Untuk mengaktifkan virtual environment, kita bisa menggunakan perintah berikut di terminal :",
      "Setelah virtual environment diaktifkan, kita bisa mulai menginstal dependensi yang diperlukan untuk proyek kita. Kita bisa menggunakan pip untuk menginstal pustaka yang kita butuhkan. Apabila anda menemukan error 'running scripts is disabled' pada saat mengaktifkan venv, silahkan jalankan perintah berikut di powershell dan jangan lupa run as admin :",
      "Lalu jalankan kembali perintah untuk mengaktifkan venv. Setelah itu kita bisa mulai menginstal dependensi yang diperlukan untuk proyek kita bebas tanpa error lagi. Apabila sudah tidak ada kendala lagi kita bisa mulai menginstal dependensi yang diperlukan untuk proyek kita. Kita bisa menggunakan pip untuk menginstal pustaka yang kita butuhkan. Misalnya kita ingin menginstal huggingface, flask, numpy berikut contohnya :",
      "Namun jika dependensi yang kita butuhkan terlalu banyak atau apabila kita ingin lebih mudah dalam setup pada folder lain, kita bisa menggunakan file requirements.txt untuk menginstal semua dependensi sekaligus. Kita bisa membuat file requirements.txt dengan menuliskan nama pustaka dan versinya satu per satu atau dengan menggunakan pip freeze. Misalnya kita ingin menginstal huggingface, flask, numpy berikut contohnya :",
      "Kesimpulannya, virtual environment adalah fitur penting dalam pengembangan Python yang memungkinkan kita untuk membuat lingkungan terisolasi untuk setiap proyek kita. Dengan menggunakan virtual environment, kita dapat menghindari konflik antara dependensi proyek yang berbeda dan menjaga proyek kita tetap rapi dan terorganisir. Dalam tutorial ini, kita telah membahas langkah-langkah untuk membuat dan mengelola virtual environment di Python dengan mudah. Semoga tutorial ini bermanfaat bagi Anda yang baru memulai belajar Python atau bagi Anda yang ingin memperdalam pemahaman tentang virtual environment.",
    ],
    images: [
      "/assets/googledeepmind.webp",
      "",
      "",
      "/assets/ctrlshiftp.webp",
    ],
    codes: [
      "",
      "choco install python",
      "",
      ".venv/Scripts/activate",
      "Set-ExecutionPolicy Unrestricted -Scope Process",
      "pip install huggingface_hub\npip install flask\npip install numpy",
      "pip install -r requirements.txt\n\n#pastikan sudah mengisi requirements.txt dengan benar, contoh isi requirements.txt\nflask==2.3.2\nfaiss-cpu==1.7.4\nsentence-transformers==2.2.2\nflask-cors==3.0.10\nrequests==2.31.0\n#bisa juga menggunakan pip freeze > requirements.txt untuk membuat file requirements.txt secara otomatis",
    ],
    languages: [
      "", 
      "bash",
      "",
      "bash",
      "bash",
      "bash",
      "bash",
    ],
    formulas: [
      "",
      "",
      "",
    ],
  },
  {
    slug: "arsitektur-lstm",
    title: "Arsitektur Dasar LSTM",
    date: "2024-11-01",
    description: "Penjelasan singkat dan padat tentang bagaimana Long Short-Term Memory (LSTM) bekerja. Cocok untuk memahami dasar-dasar arsitektur yang banyak digunakan dalam pemrosesan data berurutan.",
    paragraphs: [
      "LSTM (Long Short-Term Memory) adalah salah satu arsitektur AI yang bisa mengingat informasi dalam jangka waktu yang lebih panjang dibandingkan arsitektur lainnya. Teknologi ini banyak digunakan untuk memahami bahasa manusia, menerjemahkan kalimat, mengenali suara, atau memprediksi sesuatu berdasarkan data sebelumnya..",
      "Bayangkan LSTM sebagai seseorang yang membaca sebuah cerita panjang. Orang ini harus mengingat bagian bagian penting dari cerita tersebut agar bisa memahami keseluruhan isi ceritanya. Namun, tidak semua detail harus diingat. Ada hal hal tertentu yang boleh dilupakan, dan ada juga yang harus terus diingat agar cerita tersebut tetap bisa dipahami sampai selesai.",
      "Dalam LSTM, ada beberapa bagian penting, yaitu:",
      "**Input**: Informasi baru yang diterima di setiap langkah (seperti kalimat baru dalam cerita).\n- **Hidden state**: Memori jangka pendek yang menyimpan informasi yang relevan saat ini.\n- **Cell state**: Memori jangka panjang yang bisa menyimpan informasi penting dari jauh sebelumnya.",
      "Supaya LSTM bisa mengingat dan melupakan informasi secara selektif, ada tiga 'gerbang' yang bekerja seperti filter:",
      "**Forget gate** : Memutuskan informasi lama mana yang harus dilupakan atau tetap disimpan. Bayangkan gerbang ini seperti seseorang yang memilih mana informasi lama yang penting, mana yang sudah tidak relevan lagi.\n- **Input gate** : Memilih informasi baru mana yang akan disimpan ke dalam memori jangka panjang (cell state). Ini seperti seseorang yang menentukan apakah informasi baru tersebut penting untuk diingat atau tidak.\n- **Output gate** : Memutuskan bagian mana dari memori jangka panjang yang harus digunakan saat ini untuk menghasilkan suatu respon atau prediksi.",
      "Setiap kali LSTM menerima informasi baru, ketiga gerbang ini bekerja bersama-sama untuk memperbarui ingatan sistem, menentukan apa yang perlu diingat, apa yang bisa dilupakan, serta apa yang akan digunakan sebagai output atau hasil.",
      "Dengan kemampuan unik ini, LSTM sangat efektif digunakan dalam tugas-tugas yang membutuhkan pemahaman konteks atau hubungan informasi dalam waktu yang lama, seperti analisis sentimen, prediksi cuaca, atau menerjemahkan teks dalam bahasa yang berbeda.",
      "Agar lebih jelas, kita akan langsung praktek melakukan prediksi menggunakan LSTM. Kita akan membuat prediksi angka berikutnya berdasarkan angka sebelumnya. Tolong siapkan vscode dan siapkan juga venv, apabila belum bisa membaca tutorial setup venv agungg.com/ilmu-mahal/Venv. Apabila sudah lakukan instalasi berikut ini:",
      "Setelah itu kita buat file notebook baru, misalnya lstm.ipynb. pastikan install juga ipykernel, cara installnya tinggal buat code cell baru dan lalu run cellnya maka vscode akan otomatis menyarankan untuk install ipykernel lalu pencet install. Barulah setelah terinstall kita isi lstm.ipynb dengan kode berikut :",
      "Pada cell 1 kita mengimport library yang diperlukan untuk membuat model LSTM. selanjutnya isi cell 2 dengan kode berikut :",
    ],  
    images: [
      "/assets/ship.webp",
      "",
      "",
      "",
    ],
    codes: [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "pip install tensorflow\npip install numpy\npip install matplotlib",
      "#cell 1\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import LSTM, Dense",
      "#cell 2\n# Menyiapkan dataset sederhana (deret angka)\ndata = np.array([i for i in range(1, 101)])  # angka dari 1 hingga 100 (1, 2, 3, ..., 99, 100)",
    ],
    languages: [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "bash",
      "python",
      "python",
    ],
    formulas: [
      "",
      "",
      "",
    ],
  },
  {
    slug: "mobilenet-vs-yolov8",
    title: "Bedanya MobileNet dan YOLOv8",
    date: "2024-10-31",
    description: "Perbandingan singkat antara MobileNet dan YOLOv8 dua arsitektur populer di dunia computer vision, dengan tujuan, kekuatan, dan cara kerja yang berbeda.",
    paragraphs: [
      "saat ini kita sering mendengar istilah YOLOv8 dan MobileNet dalam dunia computer vision. Keduanya adalah arsitektur yang banyak digunakan untuk berbagai aplikasi seperti deteksi objek, pengenalan wajah, dan segmentasi gambar. Namun, meskipun keduanya memiliki tujuan yang sama, mereka memiliki pendekatan yang berbeda dalam mencapai tujuan tersebut.",
    ],
    images: [
      "/assets/333.webp",
      "",
      "/assets/333.webp",
      "",
    ],
    codes: [
      "focal_length_pixel = 481\n\ndef hitung_jarak(tinggi_bounding_box, focal_length_pixel, tinggi_objek_nyata):\n if tinggi_bounding_box == 0: \n return float('inf')\n jarak = (tinggi_objek_nyata * focal_length_pixel) / tinggi_bounding_box\nreturn jarak / 100",
      "",
      "def hitung_jarak_euclidean(landmark1, landmark2, lebar_img):\n jarak_pix = math.sqrt((landmark1.x - landmark2.x) ** 2 + (landmark1.y - landmark2.y) ** 2) * lebar_img\n return jarak_pix",
      "",
    ],
    languages: [
      "python", 
      "",
      "python",
      " ",
    ],
    formulas: [
      "",
      "",
      "",
    ],
  },
  {
    slug: "gui-roblox-script-gacor",
    title: "GUI Roblox Kunci Script yang Gacor",
    date: "2024-10-19",
    description: "Script yang bagus tidak akan berguna tanpa GUI yang bagus juga. Cara mudah buat GUI untuk script roblox dengan chatgpt.",
    paragraphs: [
      "Bagi seorang yang suka melakukan exploit pada roblox pasti sudah tidak asing lagi dengan istilah GUI. GUI adalah antarmuka pengguna grafis yang memungkinkan pengguna untuk berinteraksi dengan aplikasi atau perangkat lunak melalui elemen visual seperti tombol, menu, dan jendela. Dalam konteks roblox, GUI digunakan untuk membuat antarmuka yang menarik dan mudah digunakan untuk script yang kita buat.",
    ],
    images: [
      "/assets/blox.webp",
      "",
      "/assets/blox.webp",
      "",
    ],
    codes: [
      "focal_length_pixel = 481\n\ndef hitung_jarak(tinggi_bounding_box, focal_length_pixel, tinggi_objek_nyata):\n if tinggi_bounding_box == 0: \n return float('inf')\n jarak = (tinggi_objek_nyata * focal_length_pixel) / tinggi_bounding_box\nreturn jarak / 100",
      "",
      "def hitung_jarak_euclidean(landmark1, landmark2, lebar_img):\n jarak_pix = math.sqrt((landmark1.x - landmark2.x) ** 2 + (landmark1.y - landmark2.y) ** 2) * lebar_img\n return jarak_pix",
      "",
    ],
    languages: [
      "python", 
      "",
      "python",
      " ",
    ],
    formulas: [
      "",
      "",
      "",
    ],
  },
  {
    slug: "cara-mudah-rubik-5x5",
    title: "Cara Mudah Selesaikan Rubik 5x5",
    date: "2024-10-10",
    description: "Panduan sederhana untuk menyelesaikan Rubik 5x5 tanpa pusing.",
    paragraphs: [
      "rubik adalah permainan teka-teki yang sangat populer di seluruh dunia. Salah satu variasi yang paling menantang adalah Rubik 5x5. Dalam tutorial ini, kita akan membahas cara mudah untuk menyelesaikan Rubik 5x5 tanpa pusing. Kita akan menggunakan metode layer by layer yang sederhana dan mudah dipahami.",
    ],
    images: [
      "/assets/rubik.webp",
      "",
      "/assets/rubik.webp",
      "",
    ],
    codes: [
      "focal_length_pixel = 481\n\ndef hitung_jarak(tinggi_bounding_box, focal_length_pixel, tinggi_objek_nyata):\n if tinggi_bounding_box == 0: \n return float('inf')\n jarak = (tinggi_objek_nyata * focal_length_pixel) / tinggi_bounding_box\nreturn jarak / 100",
      "",
      "def hitung_jarak_euclidean(landmark1, landmark2, lebar_img):\n jarak_pix = math.sqrt((landmark1.x - landmark2.x) ** 2 + (landmark1.y - landmark2.y) ** 2) * lebar_img\n return jarak_pix",
      "",
    ],
    languages: [
      "python", 
      "",
      "python",
      " ",
    ],
    formulas: [
      "",
      "",
      "",
    ],
  },
];
